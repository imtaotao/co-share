<template>
  <div>
    <div
      data-x='-11000'
      data-rotate-z='90'
      styleName='title'
      id='autoActuatorOne'
      className='step pure-text'
    >
      <div styleName='left-title'>我们写一个函数来自动执行 gen.next()</div>

      <pre
        v-lighlight
        className='hljs pure-code'
      >
        <code >
          function co (fn, ...args) {
            return new Promise((resolve, reject) => {
              const gen = fn(...args)

              function next (result) { ... }

              function onFulfilled (res) { ... }

              function onRejected (err) { ... }

              onFulfilled()
            })
          }
        </code>
      </pre>
    </div>

    <div
      data-x='-11000'
      data-rotate-z='90'
      id='autoActuatorTwo'
      className='step pure-text'
    >
      <pre
        v-lighlight
        className='hljs pure-code'
      >
        <code>
          // 自动调用 gen.next()
          // 然后调用 next() 将结果传入到 generator 对象内部
          function onFulfilled (res) {
            let result

            try {
              result = gen.next(res)
              next(result)
            } catch (err) {
              return reject(err)
            }
          }
        </code>
      </pre>
    </div>

    <div
      data-x='-11000'
      data-rotate-z='90'
      id='autoActuatorThree'
      className='step pure-text'
    >
      <pre
        v-lighlight
        className='hljs pure-code'
      >
        <code>
          // 发生错误调用 gen.throw()
          // 这可以让 generator 函数内部的 try/catch 捕获到
          function onRejected (res) {
            let result

            try {
              result = gen.throw(err)
              next(result)
            } catch (e) {
              return reject(e)
            }
          }
        </code>
      </pre>
    </div>

    <div
      data-x='-11000'
      data-rotate-z='90'
      id='autoActuatorFour'
      className='step pure-text'
    >
      <pre
        v-lighlight
        className='hljs pure-code'
      >
        <code>
          // 接受到结果后再次调用 onFulfilled
          // 继续执行 generator 内部的代码
          function next (result) {
            let value = result.value
            if (result.done) return resolve(value)

            // 如果是 generator 函数，等待整个 generator 函数执行完毕
            if (
                value && value.constructor && 
                alue.constructor.name === 'GeneratorFunction'
            ) {
              value = co(value)
            }

            // 转为 promise
            Promise.resolve(value).then(onFulfilled, onRejected)
          }
        </code>
      </pre>
    </div>

    <div
      data-x='-11000'
      data-rotate-z='90'
      id='autoActuatorOne'
      className='step pure-text'
      styleName='title conclusion'
    >
      # 在这个名叫 co 的自执行函数里面<br/>
      # onFulfilled 调用 next<br/>
      # next 调用 onFulfilled<br/>
      # 这样就形成一个自执行器，只有当代码全部执行完毕后才会终止
    </div>
  </div>
</template>

<script>
  const Grass = require('@Grass')
  const style = require('../style.css')
  module.exports = Grass.CSSModules(style)(
    class AutoActuator extends Grass.Component {
      // #temp
    }
  )
</script>